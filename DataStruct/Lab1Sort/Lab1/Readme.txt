 1. 理论分析：
很容易得到：
n/k 个长度为k的子列插入排序的时间复杂度： (n/k) * c1 * k²；
在这之上归并排序的时间复杂度： c2 *  n * (㏒n - ㏒k) ；
故，O(f(n, k)) = c1 * (n/k) * k² + c2 * n * (㏒n - ㏒k) = nk +n㏒(n/k)
整理得：上式 = n * [(c1 * k - c2 * ㏒k) + ㏒n]
显然，对任意取定的n，其大小只与c1 * k - c2 * ㏒k有关，
对其求导，得(c1 * k - c2 * ㏒k)' = c1 - 1/(k * ㏑10) 
显然，该导数单调递增
易知，当 k = c2 / (c1 * ㏑10) 时，函数有唯一的极小值，也是其最小值

2. 实验过程：
①测c1、c2的值：用随机生成的nums(60)组长度为lenthA(8000)的数组，进行测试
由于实际c1 ，c2 的值很小，而我们其实只需要知道其比值，故实验中并没有计算其真实值；
②计算c2/c1；
③由②的结果计算k，重复nums(60)次，取其平均值得出k的理论值 ；
④验证k的真实值：为减少误差，假设真实的k的大小在0.7*k到1.3*k之间，
对于每一个k，都用随机生成的nums(60)组长度为lenthA(8000)的数组进行测试；
将结果绘成t(所花费时间) - k 曲线，理论上应呈现一个先减后增——下凸的曲线，
最靠近曲线拐点的整数就是k的真实值。
（而程序中，则在最后验证k的时候寻找用时最短的的k作为k的真实值，
但这样做很容易被偶尔出现的误差较大的数据组干扰，故画图找趋势更好）

3. 文件说明
Sort.h 封装了所需的三个算法，其由Sort.cpp实现；
SeekForK.cpp 完成实验的主要步骤；
图像.docx则是最后用作图得到K值的过程；
test.cpp 则是用于测试三种排序算法是否正确；
SeekForK.exe是SeekForK.cpp和Sort.cpp编译后的可执行文件(该文件大概运行10min出结果)；
testResult.exe是test.cpp和Sort.cpp编译后的可执行文件；